const fs = require('fs')
const crypto = require('crypto')
const session = Buffer.from('' + Math.random() + new Date().getTime()).toString('base64')

const parsed = JSON.parse(fs.readFileSync('parsed.json'))

console.log(createTestFile(parsed))

function createRequestBody(paragraph) {
    return JSON.stringify({
        "responseId": Buffer.from('' + Math.random() + new Date().getTime()).toString('base64'),
        "queryResult": {
          "queryText": "",
          "parameters": paragraph.annotation.conditions.reduce((acc, condition) => {
            let el = {}
            el[condition.key] = conditionToValue(condition)
            return Object.assign({}, acc, el)
          }, {}),
          "allRequiredParamsPresent": true,
          "fulfillmentMessages": [
            {
              "text": {
                "text": [
                  ""
                ]
              }
            }
          ],
          "outputContexts": [
            // {
            //   "name": "projects/test",
            //   "lifespanCount": 1,
            //   "parameters": {
            //      "Parameter": "Value that fits criteria"
            //   }
            // }
          ],
          "intent": {
            "name": Buffer.from('' + Math.random() + new Date().getTime()).toString('base64'), // "projects/dexa-developer-agent-refact-fm/agent/intents/3096cb6b-5858-4d22-8d84-caa1d478fd5e",
            "displayName": paragraph.annotation.intent
          },
          "intentDetectionConfidence": 1,
          "languageCode": "de"
        },
        "originalDetectIntentRequest": {
          "payload": {}
        },
        "session": "projects/" + Buffer.from('' + Math.random() + new Date().getTime()).toString('base64')
      })
}

function conditionToValue(condition) {
    switch (condition.compare) {
        case '==':
        case '===':
        case '<=':
        case '>=':
            return condition.value
            break;
        case '<':
            return parseInt(condition.value, 10)--;
            break;
        case '>':
            return parseInt(condition.value, 10)++;
            break;
        // '!='
        default:
            return parseInt(condition.value) == 'NaN' ? 'Anything other than [specified value]' : parseInt(condition.value, 10)++
            break;
    }
}

function createTestFile(paragraphs) {
    const testCases = paragraphs.reduce((acc, paragraph) => acc += createTestCode(paragraph), '')

    return `
// This file is generated by the Bot end to end testing framework
require('dotenv').config()
const request = require('request')

const API_ENDPOINT = process.env.API_ENDPOINT

describe('The API should work for', () => {
    ${testCases}
})
`
}

function createTestCode(paragraph) {
    return `
    it('[${paragraph.annotation.intent}]${paragraph.annotation.conditions && paragraph.annotation.conditions ? printConditions(paragraph.annotation.conditions) : 'none'}', (done) => {
        request({
            uri: API_ENDPOINT + '/dialogflow/message',
            method: 'POST',
            json: ${createRequestBody(paragraph)}
        }, (err, res, body) => {
            if (err) done.fail(err)
            expect(res.statusCode).toBe(200)
            done()
        })
    })
    `
}

function printConditions(conditions) {
    return conditions.reduce((acc, condition) => acc += ` (${condition.key} ${condition.compare} ${condition.value})`, '')
}
